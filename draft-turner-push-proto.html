<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Simply Push Protocol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Simply Push Protocol">
<meta name="keywords" content="Internet-Draft">
<meta name="generator" content="xml2rfc v1.36 (http://xml.resource.org/)">
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: small; color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: small; font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: small; font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: small; text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">D. Turner</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Mozilla</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">April 29, 2014</td></tr>
<tr><td class="header">Expires: October 31, 2014</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Simply Push Protocol<br />draft-turner-push-proto-latest</h1>

<h3>Abstract</h3>

<p>This page describes the protocol used for communication by the PushServer and the UserAgent.
</p>
<p>A reference server is available on [https://github.com/dougt/go-push-server github].
</p>
<h3>Status of This Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on October 31, 2014.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2014 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<p>
This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008.  The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s) controlling
the copyright in such materials, this document may not be modified
outside the IETF Standards Process, and derivative works of it may
not be created outside the IETF Standards Process, except to format
it for publication as an RFC or to translate it into languages other
than English.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#introduction">1.</a>&nbsp;
Introduction<br />
<a href="#definitions">2.</a>&nbsp;
Definitions<br />
<a href="#protocol-overview">3.</a>&nbsp;
Protocol Overview<br />
<a href="#considerations">4.</a>&nbsp;
Considerations<br />
<a href="#channelid-uaids-and-endpoint">5.</a>&nbsp;
ChannelID, UAIDs and Endpoint<br />
<a href="#messages">6.</a>&nbsp;
Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#handshake">6.1.</a>&nbsp;
Handshake<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#useragent-pushserver">6.1.1.</a>&nbsp;
UserAgent -&gt; PushServer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pushserver-useragent">6.1.2.</a>&nbsp;
PushServer -&gt; UserAgent<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#register">6.2.</a>&nbsp;
Register<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#useragent-pushserver-1">6.2.1.</a>&nbsp;
UserAgent -&gt; PushServer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pushserver-useragent-1">6.2.2.</a>&nbsp;
PushServer -&gt; UserAgent<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#unregister">6.3.</a>&nbsp;
Unregister<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#useragent-pushserver-2">6.3.1.</a>&nbsp;
UserAgent -&gt; PushServer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pushserver-useragent-2">6.3.2.</a>&nbsp;
PushServer -&gt; UserAgent<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ping">6.4.</a>&nbsp;
Ping<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#useragent-pushserver-3">6.4.1.</a>&nbsp;
UserAgent -&gt; PushServer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pushserver-useragent-3">6.4.2.</a>&nbsp;
PushServer -&gt; UserAgent<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#notification">6.5.</a>&nbsp;
Notification<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#appserver-pushserver">6.5.1.</a>&nbsp;
AppServer -&gt; PushServer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pushserver-appserver">6.5.2.</a>&nbsp;
PushServer -&gt; AppServer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pushserver-useragent-4">6.5.3.</a>&nbsp;
PushServer -&gt; UserAgent<br />
<a href="#synchronization-of-server-and-client-state">7.</a>&nbsp;
Synchronization of server and client state<br />
<a href="#achieving-reliable-delivery">8.</a>&nbsp;
Achieving reliable delivery<br />
<a href="#garbage-collection">9.</a>&nbsp;
Garbage collection<br />
<a href="#alternative-communication">10.</a>&nbsp;
Alternative communication<br />
<a href="#security-considerations">11.</a>&nbsp;
Security Considerations<br />
<a href="#iana-considerations">12.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">13.</a>&nbsp;
Normative References<br />
</p>
<br clear="all" />

<a name="introduction"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The SimplePush protocol is closely based on [http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/pubs/archive/37474.pdf Thialfi: A Client Notification Service for Internet-Scale Applications] and makes the same delivery guarantees, soft server state and client driven recovery. It is a signaling and not a data carrying system.
</p>
<p>The goal: To notify clients of changes to application server state in a reliable manner by ensuring that the client will always eventually learn of the latest version of an object for which it has expressed interest.
</p>
<a name="definitions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Definitions</h3>

<p></p>
<blockquote class="text"><dl>
<dt>PushServer</dt>
<dd>
  A publicly accessible server that implements the server side of the Push Protocol and exposes an HTTP API for AppServer’s to notify it.
</dd>
<dt>UserAgent</dt>
<dd>
  A device or program that implements the client side of the Push Protocol.
</dd>
<dt>UAID</dt>
<dd>
  A globally unique UserAgent ID. Used by the PushServer to associate channelIDs with a client. Stored by the UserAgent, but opaque to it.
</dd>
<dt>Channel</dt>
<dd>
  The flow of information from AppServer through PushServer to UserAgent.
</dd>
<dt>ChannelID</dt>
<dd>
  Unique identifier for a Channel. Generated by UserAgent for a particular application. Opaque identifier for both UserAgent and PushServer. This MUST NOT be exposed to an application.
</dd>
<dt>Endpoint</dt>
<dd>
  A REST-ful HTTP URL uniquely associated to a channel. Requests to this URL should update the PushServer state for the channel. MUST be exposed to applications.
</dd>
<dt>Version</dt>
<dd>
  Monotonically increasing 64-bit integer describing the application state. This
holds meaning as a primary key or similar only to the AppServer. The PushServer
and UserAgent and App should use this only for detecting changes. MUST be exposed to applications.
</dd>
<dt>Application</dt>
<dd>
  A program which requires access to push notifications. The UserAgent acts on behalf of applications.
</dd>
</dl></blockquote>

<a name="protocol-overview"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Protocol Overview</h3>

<p>The SimplePush protocol defines how UserAgents and PushServers communicate to ensure reliable delivery of the latest version of a channel from the PushServer to the UserAgent.
</p>
<p>The SimplePush communication channel is WebSockets, and the wire protocol is JSON, with messages defined below.
The WebSocket specific HTTP header <tt>Sec-WebSocket-Protocol</tt> MUST be set to <tt>push-notification</tt> by the UserAgent. The PushServer SHOULD reject the connection if the header is not set. (FIXME: MUST/SHOULD paradox?)
</p>
<p>All messages MUST use TLS (wss:// protocol for WebSockets). In addition, Endpoints generated by PushServer’s MUST use HTTPS URLs.
</p>
<p>The PushServer should maintain a mapping of channelIDs and their versions and pushEndpoints.
SimplePush is backed by a best effort delivery mechanism over WebSocket
</p>
<p>The protocol has some request-response driven actions, where the UserAgent MUST make requests, and the PushServer MAY respond. One message, <tt>notification</tt>, MAY be sent at any time by the PushServer.
</p>
<a name="considerations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Considerations</h3>

<p>Since SimplePush is not a data carrying system, there are a few things developers should keep in mind.
</p>
<p></p>
<ol class="text">
<li><em>Do not send a SimplePush update message for every bit of exchanged data.</em>
</li>
</ol>

<p>This service is a way for you to wake your remote app and have it reconnect back to you. If it’s already connected, sending a SimplePush service is wasteful. (It’s a bit like sending a fax to make sure the person on the phone got your email.)
</p>
<p></p>
<ol class="text">
<li><em>While it’s possible to have more than one Channel per App, it helps to be frugal about them.</em>
</li>
</ol>

<p>Remember, that each Channel has an associated action, and that they’re not really “free”, and they can be lossy. A single channel that allows the system to start your app, or a separate channel that advises that a screen widget needs to be updated are all fine uses. Having one channel per bullet path for a FPS game is not, since this will pretty much guarantee data will be lost. 
</p>
<p></p>
<ol class="text">
<li><em>Don’t flood the channel.</em>
</li>
</ol>

<p>Nobody likes having something constantly remind you to do something, particularly after you’ve already done it. In the same way, be conscious that channel updates invoke actions on your user’s devices, and may lead to users removing your app. Once your app connects, you’ll have a far more efficient and faster pipe than SimplePush. 
</p>
<p></p>
<ol class="text">
<li><em>Pay attention to endpoint reassignments.</em>
</li>
</ol>

<p>When a given user’s endpoint changes, the previous endpoint is no longer valid. Updates sent to that endpoint will no longer have any effect and are a waste of your bandwidth. If you send a great many updates to endpoints that are invalid, the server may have a very difficult time determining that you’re not being hostile. 
</p>
<a name="channelid-uaids-and-endpoint"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
ChannelID, UAIDs and Endpoint</h3>

<p>Since the UAID is the only unique identifier of a UserAgent, with no authentication information, it is important that UAIDs are not compromised. Only the UserAgent to which the UAID was assigned, and the PushServer, should know the UAID. An attacker can use a leaked UAID to pretend to be the UserAgent with that UAID. Although SimplePush does not transfer any private information, the attacker would still receive the notifications meant for the victim. If any party detects a compromise, they SHOULD reset the UAID. For this, the UserAgent may send a blank UAID and get a new one from the PushServer. Similarly the PushServer may send a new UAID during a handshake.
</p>
<p>ChannelIDs are also unique. It is RECOMMENDED that channelIDs be associated with a UAID, so that an attacker cannot receive notifications for a compromised channelID without also having accessed the UAID.
</p>
<p>It is REQUIRED that both UAID and channelIDs be UUIDv4 tokens.
</p>
<p>The format of the Endpoint is not specified by this protocol. There are two requirements that MUST be satisfied:
</p>
<p></p>
<ul class="text">
<li>PushServers MUST use HTTPS, so the Endpoint URL will begin with “https://”.
</li>
<li>ChannelIDs and Endpoints MUST have a one-one mapping and Endpoints may not ‘expire’ while their channelID is still active.
</li>
</ul>

<p>It is RECOMMENDED that Endpoints simply be a prefix followed by the channelID or some transformation of the channelID which is referentially transparent. PushServers SHOULD avoid exposing UAIDs in the Endpoints since they are sent to AppServers.
</p>
<a name="messages"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Messages</h3>

<p>All messages are encoded as JSON. All messages MUST have the following fields:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>messageType (string)</dt>
<dd>
  Defines the message type
</dd>
</dl></blockquote>

<a name="handshake"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Handshake</h3>

<p>After the WebSocket is established, the UserAgent begins communication by
sending a <tt>hello</tt> message.  The hello message contains the UAID if the
UserAgent has one, either generated by the UserAgent for the first handshake or
returned by the server from an earlier handshake. The UserAgent also transmits
the channelIDs it knows so the server may synchronize its state.
</p>
<p>The server MAY respect this UAID, but it is at liberty to ask the UserAgent
to change its UAID in the response.
</p>
<p>If the UserAgent receives a new UAID, it MUST delete all existing channelIDs
and their associated versions. It MAY then wake up all registered applications
immediately or at a later date by sending them a <tt>push-register</tt>
message.
</p>
<p>The handshake is considered ‘‘complete’’, once the UserAgent has received a reply.
</p>
<p>An UserAgent MUST transmit a <tt>hello</tt> message <em>only once</em> on its
WebSocket.  If the handshake is not completed in the first try, it MUST
disconnect the WebSocket and begin a new connection.
</p>
<p><em>NOTE:</em> Applications may request registrations or unregistrations from the
UserAgent, before or when the handshake is in progress. The UserAgent MAY
buffer these or report errors to the application. But it MUST NOT send these
requests to the PushServer until the handshake is completed.
</p>
<a name="useragent-pushserver"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.1"></a><h3>6.1.1.&nbsp;
UserAgent -&gt; PushServer</h3>

<p></p>
<blockquote class="text"><dl>
<dt>messageType = “hello”</dt>
<dd>
  Begin handshake
</dd>
<dt>uaid string (REQUIRED)</dt>
<dd>
  If the UserAgent has a previously assigned UAID, it should send it. Otherwise send an empty string.
</dd>
<dt>channelIDs list of strings (REQUIRED)</dt>
<dd>
  If the UserAgent has a list of channelIDs it wants to be notified of, it must pass these, otherwise an empty list.
</dd>
</dl></blockquote>

<p>Extra fields:
The UserAgent MAY pass any extra JSON data to the PushServer. This data may include information required to wake up the UserAgent out-of-band. The PushServer MAY ignore this data.
</p>
<a name="example"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.1.1"></a><h3>6.1.1.1.&nbsp;
Example</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  {
    "messageType": "hello",
    "uaid": "fd52438f-1c49-41e0-a2e4-98e49833cc9c",
    "channelIDs": ["431b4391-c78f-429a-a134-f890b5adc0bb",
                   "a7695fa0-9623-4890-9c08-cce0231e4b36"]
  }
</pre></div>
<a name="pushserver-useragent"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.2"></a><h3>6.1.2.&nbsp;
PushServer -&gt; UserAgent</h3>

<p>PushServers MUST only respond to a hello once.
UserAgents MUST ignore multiple hello replies.
</p>
<p></p>
<blockquote class="text"><dl>
<dt>messageType = “hello”</dt>
<dd>
  Responses generally have the same messageType as the request
</dd>
<dt>uaid string (REQUIRED)</dt>
<dd>
  If the UserAgent sent no UAID, generate a new one. If the UserAgent send a valid UAID and the PushServer is in sync with the UserAgent, send back the same UAID, otherwise the PushServer should generate a new UAID.
</dd>
</dl></blockquote>

<a name="example-1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.2.1"></a><h3>6.1.2.1.&nbsp;
Example</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  {
    "messageType": "hello",
    "uaid": "fd52438f-1c49-41e0-a2e4-98e49833cc9c"
  }
</pre></div>
<a name="register"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Register</h3>

<p>The Register message is used by the UserAgent to request that the PushServer notify it when a channel changes. Since channelIDs are associated with only one UAID, this effectively creates the channel, while unregister destroys the channel.
</p>
<p>The channelID is chosen by the UserAgent because it also acts like a nonce for the Register message itself. Because of this PushServers MAY respond out of order to multiple register messages or messages may be lost without compromising correctness of the protocol. 
</p>
<p>The request is considered successful only after a response is received with a status code of 200. On success the UserAgent MUST:
</p>
<p></p>
<ul class="text">
<li>Update its persistent storage based on the response
</li>
<li>Notify the application of a successful registration. 
</li>
<li>On error, the UserAgent MUST notify the application as soon as possible.
</li>
</ul>

<p>NOTE: The register call is made by the UserAgent on behalf of an application. The UserAgent SHOULD have reasonable timeouts in place so that the application is not kept waiting for too long if the server does not respond or the UserAgent has to retry the connection.
</p>
<a name="useragent-pushserver-1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.1"></a><h3>6.2.1.&nbsp;
UserAgent -&gt; PushServer</h3>

<p>;messageType = “register”
</p>
<p>;channelID string (REQUIRED)
:A unique identifier generated by the UserAgent, distinct from any existing channelIDs it has registered. It is RECOMMENDED that this is a UUIDv4 token.
</p>
<a name="example-2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.1.1"></a><h3>6.2.1.1.&nbsp;
Example</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  {
    "messageType": "register",
    "channelID": "d9b74644-4f97-46aa-b8fa-9393985cd6cd"
  }
</pre></div>
<a name="pushserver-useragent-1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.2"></a><h3>6.2.2.&nbsp;
PushServer -&gt; UserAgent</h3>

<p>messageType = “register”
</p>
<p>channelID string (REQUIRED)
:This MUST be the same as the channelID sent by the UserAgent in the register request that this message is a response to.
</p>
<p></p>
<blockquote class="text"><dl>
<dt>status number (REQUIRED)</dt>
<dd>
  Used to indicate success/failure. MUST be one of:
* 200 - OK. Success. Idempotent: If the PushServer receives a register for the same channelID from a UserAgent which already has a registration for the channelID, it should still respond with success.
* 409 - Conflict. The chosen ChannelID is already in use and NOT associated with this UserAgent. UserAgent SHOULD retry with a new ChannelID as soon as possible.
* 500 - Internal server error. Database out of space or offline. Disk space full or whatever other reason due to which the PushServer could not grant this registration. UserAgent SHOULD avoid retrying immediately.
</dd>
<dt>pushEndpoint string (REQUIRED)</dt>
<dd>
  Should be the URL sent to the application by the UserAgent. AppServers will contact the PushServer at this URL to update the version of the channel identified by channelID.
</dd>
</dl></blockquote>

<a name="example-3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.2.1"></a><h3>6.2.2.1.&nbsp;
Example</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  {
    "messageType": "register",
    "channelID": "d9b74644-4f97-46aa-b8fa-9393985cd6cd",
    "status": 200,
    "pushEndpoint": "http://pushserver.example.org/d9b74644"
  }
</pre></div>
<a name="unregister"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
Unregister</h3>

<p>Unregistration is an optional procedure.
</p>
<p>PushServers MUST support it.
UserAgents SHOULD support it.
</p>
<p>The unregister is required only between the App and the UserAgent, so that the
UserAgent stops notifying the App when the App is no longer interested in a pushEndpoint.
</p>
<p>The unregister is also useful to the AppServer, because it should stop
sending notifications to an endpoint the App is no longer monitoring. Even
then, it is really an optimization so that the AppServer need not have some
sort of garbage collection mechanism to clean up endpoints at intervals of time.
</p>
<p>The PushServer MUST implement unregister, but need not rely on it. Well behaved
AppServers will stop notifying it of unregistered endpoints automatically. Well behaved
UserAgents won’t notify their apps of unregistered updates either. So the PushServer
can continue to process notifications and pass them on to UserAgents, when it has
not been told about the unregistration.
</p>
<p>When an App calls <tt>unregister(endpoint)</tt> it is RECOMMENDED that the UserAgent follow these steps:
</p>
<p></p>
<ul class="text">
<li>Remove its local registration first, for example from the database.
This will allow it to immediately start ignoring updates.
</li>
<li>Notify the App that unregistration succeeded.
</li>
<li>Fire off an unregister message to the PushServer
</li>
</ul>

<a name="useragent-pushserver-2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3.1"></a><h3>6.3.1.&nbsp;
UserAgent -&gt; PushServer</h3>

<p>messageType = “unregister”
</p>
<p></p>
<blockquote class="text"><dl>
<dt>channelID string (REQUIRED)</dt>
<dd>
  This is sort of obvious isn’t it? :)
</dd>
</dl></blockquote>

<a name="example-4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3.1.1"></a><h3>6.3.1.1.&nbsp;
Example</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  {
    "messageType": "unregister",
    "channelID": "d9b74644-4f97-46aa-b8fa-9393985cd6cd"
  }
</pre></div>
<a name="pushserver-useragent-2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3.2"></a><h3>6.3.2.&nbsp;
PushServer -&gt; UserAgent</h3>

<p>messageType = “unregister”
</p>
<p></p>
<blockquote class="text"><dl>
<dt>channelID string (REQUIRED)</dt>
<dd>
  This MUST be the same as the channelID sent by the UserAgent in the unregister request that this message is a response to.
</dd>
<dt>status number (REQUIRED)</dt>
<dd>
  Used to indicate success/failure. MUST be one of:
* 200 - OK. Success. Idempotent: If the PushServer receives a unregister for a non-existent channelID it should respond with success. If the channelID is associated with a DIFFERENT UAID, it MUST NOT delete the channelID, but still MUST respond with success to this UserAgent.
* 500 - Internal server error. Database offline or whatever other reason due to which the PushServer could not grant this unregistration. UserAgent SHOULD avoid retrying immediately.
</dd>
</dl></blockquote>

<a name="example-5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3.2.1"></a><h3>6.3.2.1.&nbsp;
Example</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  {
    "messageType": "unregister",
    "channelID": "d9b74644-4f97-46aa-b8fa-9393985cd6cd",
    "status": 200
  }
</pre></div>
<a name="ping"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4"></a><h3>6.4.&nbsp;
Ping</h3>

<p>The connection to the Push Server may be lost due to network issues. When the UserAgent detects loss of network, it should reconnect. There are situations in which the TCP connection dies without either end discovering it immediately. The UserAgent should send a ping approximately every 30 minutes andexpect a reply from the server in a reasonable time (The Mozilla UserAgent uses 10 seconds). If no data is received, the connection should be presumed closed and a new connection started.
</p>
<p>The UserAgent should consider normal communications as an indication that the socket is working properly. It SHOULD send the ping packet only if no activity has occurred in the past 30 minutes.
</p>
<a name="useragent-pushserver-3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.1"></a><h3>6.4.1.&nbsp;
UserAgent -&gt; PushServer</h3>

<p>The 2-character string <tt>{}</tt> is sent. This is a valid JSON object that requires no alternative processing on the server, while keeping transmission size small.
</p>
<a name="pushserver-useragent-3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2"></a><h3>6.4.2.&nbsp;
PushServer -&gt; UserAgent</h3>

<p>The PushServer may reply with any data. The UserAgent is only concerned about the state of the connection. The PushServer may deliver pending notifications or other information. If there is no pending information to be sent, it is RECOMMENDED that the PushServer also reply with the string <tt>{}</tt>.
</p>
<a name="notification"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5"></a><h3>6.5.&nbsp;
Notification</h3>

<a name="appserver-pushserver"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5.1"></a><h3>6.5.1.&nbsp;
AppServer -&gt; PushServer</h3>

<p>The AppServer MUST make a HTTP <em>PUT</em> request to the Endpoint received from the App.
</p>
<p>If no request body is present, the server MAY presume the version to be the current server UTC. 
</p>
<p>If the request body is present, the request MUST contain the string “version=N” and the Content-Type MUST be <tt>application/x-www-form-urlencoded</tt>.
</p>
<a name="pushserver-appserver"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5.2"></a><h3>6.5.2.&nbsp;
PushServer -&gt; AppServer</h3>

<p>The HTTP response status code indicates if the request was successful.
</p>
<p></p>
<ul class="text">
<li>200 - OK. The PushServer will attempt to deliver a notification to the associated UserAgent.
</li>
<li>500 - Something went wrong with the server. Rare, but the AppServer should try again.
</li>
</ul>

<p>The HTTP response body SHOULD be empty.
</p>
<a name="pushserver-useragent-4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5.3"></a><h3>6.5.3.&nbsp;
PushServer -&gt; UserAgent</h3>

<p>Notifications are <em>acknowledged</em> by the UserAgent.  PushServers should
retry unacknowledged notifications every 60 seconds.  If the version of an
unacknowledged notification is updated, the PushServer MAY queue up a new
notification for this channelID and the new version, and remove the old
notification from the pending queue.
</p>
<p>messageType: “notification”
</p>
<p></p>
<blockquote class="text"><dl>
<dt>updates list  REQUIRED</dt>
<dd>
  The list contains one or more {“channelID”: “id”, “version”: N } pairs.
</dd>
</dl></blockquote>

<a name="example-6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5.3.1"></a><h3>6.5.3.1.&nbsp;
Example</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  {
    "messageType": "notification",
    "updates": [
      { "channelID": "431b4391-c78f-429a-a134-f890b5adc0bb",
        "version": 23 },
      { "channelID": "a7695fa0-9623-4890-9c08-cce0231e4b36",
        "version": 42 } ]
  }
</pre></div>
<a name="useragent-pushserver-4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5.3.2"></a><h3>6.5.3.2.&nbsp;
UserAgent -&gt; PushServer</h3>

<p>It is RECOMMENDED that the UserAgent try to batch all pending acknowledgements into fewer messages.
</p>
<p>messageType =”ack”
</p>
<p></p>
<blockquote class="text"><dl>
<dt>updates list</dt>
<dd>
  The list contains one or more {“channelID”: channelID, “version”: N} pairs.
</dd>
</dl></blockquote>

<a name="example-7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5.3.2.1"></a><h3>6.5.3.2.1.&nbsp;
Example</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  {
    "messageType": "ack",
    "updates": [
       { "channelID": "431b4391-c78f-429a-a134-f890b5adc0bb",
         "version": 23 },
       { "channelID": "a7695fa0-9623-4890-9c08-cce0231e4b36",
         "version": 42 } ]
  }
</pre></div>
<a name="synchronization-of-server-and-client-state"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Synchronization of server and client state</h3>

<a name="achieving-reliable-delivery"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Achieving reliable delivery</h3>

<p>At any time, if the PushServer reaches an inconsistent condition, due to database failure, network failure, or any other reason, it MAY drop all state. It MUST then disconnect all active clients, forcing them to reconnect and begin a handshake to get synchronized.
</p>
<a name="garbage-collection"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Garbage collection</h3>

<p>The PushServer MAY perform occasional garbage collection to reduce its disk/memory usage.
UserAgents that have not contacted the PushServer for a long period of time (a few days. TODO decide minimum) are eligible for garbage collection.
To do this, the PushServer simply deletes the UAID and all associated ChannelIDs and other associated data (including versions and Endpoints).
The deletion of the UAID should be done first, and ‘‘atomically’’. Other details may be deleted when the server has spare cycles. Now if the UserAgent with said UAID connects to the PushServer, it will be assigned a new UAID, the handshake will occur and Apps on the server will learn the latest version (TODO: really need NotifyUnknown!)
</p>
<p>The PushServer MUST NOT delete channelIDs without deleting the associated UAID, except when one of the following occurs:
</p>
<p></p>
<ul class="text">
<li>The UserAgent explicitly sends an unregister message.
</li>
<li>or, When a previously known UserAgent reconnects, in the handshake it will transmit channelIDs which are registered on the UserAgent’s side. If the PushServer finds that it has registrations for channelIDs that are not in the list transmitted by the UserAgent, it may delete these extra channelIDs.
</li>
</ul>

<a name="alternative-communication"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Alternative communication</h3>

<p>In environments or devices where maintaining an always alive WebSocket is difficult, UserAgents and PushServers MAY implement alternative means to notify UserAgents about updates. This out of band notification SHOULD be restricted to request the UserAgent to establish the WebSocket. SimplePush state SHOULD NOT be transmitted out of band, since reliable delivery may not be guaranteed.
</p>
<a name="security-considerations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Security Considerations</h3>

<p>[TODO]
</p>
<a name="iana-considerations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
IANA Considerations</h3>

<p>[TODO]
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>13.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Douglas Turner II</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mozilla</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:dougt@mozilla.com">dougt@mozilla.com</a></td></tr>
</table>
</body></html>
